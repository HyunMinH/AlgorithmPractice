# 수학적 귀납법과 반복문 불변식

## 귀납법

- 반복적인 구조를 갖는 명제들을 증명하는 데 유용하게 사용하는 증명 기법

## 반복문 불변식

- 귀납법을 이용해 알고리즘의 정당성을 증명할 때는 반복문 불변식이라는 개념이 유용하게 쓰임.

- 반복문 불변식 : 반복문의 내용이 한 번 실행 될 때마다 중간 결과가 우리가 원하는 답으로 가는 길 위에 잘 있는지를 명시하는 조건

### 불변식을 이용한 반복문의 정당성 증명

1. 반복문 진입시 불변식 성립함을 보인다.

```java
// binaraySearch
// arr : 중복되지 않은 오름차순 배열

int n = arr.size();
int lo = -1, hi = n;

 // 불변식은 여기에서 성립해야 한다.

 반복분 불변식 1 : lo < hi
 lo = -1이고 hi가 n이니 성립

 반복문 불변식 2 : A[lo] < x <= A[hi]
 arr이 오름차순으로 정렬되어 있다고 하고 시작하였으니
 당연히 A[lo] < x <= A[hi] 성립

while(...){
    ...
}
```

2. 반복문 내용이 시작할 때 불변식이 성립했다면, 내용이 끝날 때도 불변식이 항상 성립함을 보인다.

```java
while(lo + 1 <hi){
    // 반복문 내용의 시작
    
    int mid = (lo + hi) / 2;
    if(A[mid] < x) lo = mid;
    else hi = mid;

    // 반복문 내용의 끝
    // 불변식은 여기에서도 성립해야 한다.

     반복분 불변식 1 : lo < hi
     1. lo에 mid 대입됐을 경우 -> lo <= mid < hi 이므로 위 불변식 성립
     2. hi 에 mid가 대입되는 경우 -> x <= A[mid]이다. 아래에서 보겠지만 
        이 때 A[lo] < x 이므로 A[lo] < A[mid]임을 알 수 있다.
        arr이 중복되지 않은 오름차순 배열이라면 lo < mid 임을 알 수 있다.

     반복문 불변식 2 : A[lo] < x <= A[hi]
     1. lo에 mid가 대입됐을 경우 -> A[mid] < x 이다.
     2. hi에 mid가 대입됏을 경우 -> x <= A[mid]이다.
}
```

3. 반복문 종료시에 불변식이 성립하면 항상 우리가 정답을 구했음을 보인다.

```java
while(lo + 1 < hi){
    ...
}

 반복분 불변식 1 : lo < hi
 while문이 종료했으니 lo+1 >= hi인데, 불변식에 의하면 lo < hi이니 lo+1 = hi일 수 밖에 없다.

 반복문 불변식 2 : A[lo] < x <= A[hi]
 lo + 1 = hi 이므로 -> lo < hi 라서 위 불변식이 성립한다.

return hi; -> A[i-1] < x <= A[i] 인 i를 반환하므로 정답을 구하였다.
```

### 단정문

- 단벙문을 이용해서 반복문 불변식을 강제할 수 있다.

- 다만 어느 정도 속도에 지장 주니 엄청나게 많이 실행되는 반복문 안에는 삼가자.

> 책에 있는 삽입정렬에도 반복문 불변식을 적용해보자
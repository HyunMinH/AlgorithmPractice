# 풀이

## 입력

1. L : 통나무의 길이

2. K : 통나무를 자를 수 있는 위치의 갯수

3. C : 최대 자를 수 있는 횟수

4. K개의 숫자 : 통나무를 자를 수 있는 위치들

## 출력

1. 최대 C개만큼 자를 수 있을 때, 제일 긴 통나무의 최솟값

## 접근

1. 문제를 손으로 푸는 방법을 택하였다. 그러다보니 이분탐색과 greedy를 취해야겠다는 생각이 들었다.

2. greedy : 한번 자를 때 최대한 반으로 자르면 최적해를 구할 수 있다는 점

3. 단순 이분탐색보다는 PriorityQueue에 통나무를 넣는다 -> 이를 통해 바로 제일 큰 통나무를 구할 수 있다.

4. HashMap을 통해 각 통나무가 마지막으로 잘렸던 위치를 저장

5. 더 이상 긴 나무를 자르지 못하거나 or C번만큼 잘랐을 때까지 제일 긴 통나무를 고르고 자르는 과정을 반복

## 느낀 점

1. 일단 정말정말 좋은 문제였다. 평소에 잘 접하지 못했던 문제여서 신선하였고 풀이방법을 떠올린건 좋았다.

2. 하지만 여러번 시도했음에도 제출한 코드가 틀렸다하였다. 뭔가 예외 케이스가 있을 것 같은데 아직 찾지 못했다. 다음에 다시 시도해봐야겠다.
